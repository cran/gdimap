##
## GQI volume processing for visualization of ODF line maps
## using vonMises clustering 
##

gqi.odfvmflines <-
function(run=TRUE, fbase=NULL, roi=NULL,  rg=c(1,1), swap=FALSE, mddratio=1.24, depth=3, btoption=2, threshold=0.4, kdir=4, zfactor=5, showglyph=FALSE, snapshot=FALSE, showimage="linesgfa", bview="coronal", savedir=tempdir(), pngfig="odfvmf", bg="white", texturefile=NA)
{
  startctl=list(E="softmax", minalpha=8, start="s", maxiter=200) ## movMF inits
  showimages <- c("none", "gfa", "lines", "linesgfa", "linesrgbmap", "linesdata") ## map types
  kshow <- match(showimage, showimages)
  bviews <- c("sagittal", "coronal", "axial")
  kv <- grep(bview, bviews)
  ##---------
  # generate S2 grid
  s2 <- s2tessel.zorder(depth=depth, viewgrid=FALSE)
  odfvertices <- s2$pc
  tcsurf <- s2$tcsurf
  ##-----------
  ## Read data
  if(btoption == 1) { ## Option 1: S2-shell (DSI 203-point 3mm)
    btable <- as.matrix(
      readtable(fbase=fbase, filename="dsi203_bmax4000.txt"))
  }
  else {
    if(btoption == 2) { ## Option 2: 3D-dsi grid as generated by dcm2niii
      bval <- scantable(fbase=fbase, filename="data.bval")
      bvec <- readtable(fbase=fbase, filename="data.bvec")
      btable <- cbind(bval,bvec)
    }
    else stop()
  }
  ##----------------------------
  cat("Reading data ...")
  img.nifti  <- readniidata(fbase=fbase, filename="data.nii.gz")
  volimg <- img.nifti@.Data  
  if(is.null(roi))
    mask.nifti <-
      readniidata(fbase=fbase, filename="data_brain_mask.nii.gz")
  else 
    mask.nifti <-
      readniidata(fbase=fbase, filename=paste(roi,".nii.gz", sep=""))
  volmask <- mask.nifti@.Data  
  ##----------------------------
  volgfa <- array(0, dim=dim(volmask)) ## gfas map
  V1 <- array(0, dim=c(dim(volmask), 3)) ## V1 direction
  d <- dim(volimg)
  if(is.null(rg)) {
    switch(kv,
      { nslices <- d[1]}, # sagittal,
      { nslices <- d[2]}, # coronal
      { nslices <- d[3]})  # axial
    first <- 1; last <- nslices
  }
  else { first <- rg[1]; last <- rg[2] }
  cat("\n")
  ##-----------------------------
  ## GQI basis 
  cat("Estimating slice odfs ...\n")
  q2odf <- gqifn(odfvert=odfvertices, btable=btable, mddratio=mddratio)
  ##-----------------------------
  ## storage of 1st vector directions
  nv1 <- length(first:last)
  v1list <- vector(mode="list", nv1)
  v1count <- 0
  npar1 <- 7
  npar2 <- 15
  # rglstart()
  for (sl in (first:last)) {
    cat("slice",sl,"\n")
    #-------------------
    slicedata <- read.slice(img=volimg, mask=volmask, slice=sl,
       swap=swap, bview=bview)
    ymaskdata <- premask(slicedata)
    if(ymaskdata$empty) next # empty mask
    #-------------------
    ## odfs
    odfs <- q2odf %*% (ymaskdata$yn)
    odfs <- apply(odfs, 2, norm01) ## normalize 
    #-------------------
    ## gfas
    gfas <- apply(odfs, 2, genfa)
    gfas <- norm01(gfas) ## ??
    z2d <- ymaskdata$kin
     ## mask out thresholded values
    zx <- which(gfas <= threshold)
    if(length(zx)) {
      z2d <- z2d[-zx,]
      gfas <- gfas[-zx]
      odfs <- odfs[,-zx]
    }
    if(is.null(dim(z2d))) next
    if(length(gfas) < 8) next # 8 elements as minimum number
    lix <- dim(z2d)[1]
    switch(kv,
      { nr <- d[2]; nc <- d[3]}, # sagittal,
      { nr <- d[1]; nc <- d[3]}, # coronal
      { nr <- d[1]; nc <- d[2]})  # axial
    # nn <- 8*nr*nc
    nn <- nr*nc
    ck <- numeric(nn)
    v <- matrix(0, nrow=nn, ncol=3)
    q <- 1
    v1perslice <- matrix(0, nrow=lix,ncol=3) # store v1 directions 
    nullvectors <- NULL
    if(run) {
      ## ptm <- proc.time()
      tperc <- c(20, 40, 60, 80)
      tline <- floor(c(0.2,0.4,0.6,0.8)*lix) 
      cat("vMF estimation for ", lix, "voxels, ...\n")
      for(m in 1:lix) {
        tt <- which(tline == m)
        if(length(tt) != 0) {
          cat(paste(tperc[tt],"% ", sep="")); cflush() }
        odf <- odfs[,m]
        ## Find peaks based on clusters
        ith <- which(odf < threshold) 
        vx <- odfvertices[-ith,]
        n <- dim(vx)[1]
        ## Fit a vMF mixture  with k=2
        y1 <- movMF(vx, k=2, control=startctl) 
        par1 <- logb(n)*npar1
        bic1 <- 2*logLik(y1) - par1
        ## Fit a vMF mixture  with k=4
        y2 <- movMF(vx, k=4, control=startctl) 
        par2 <- logb(n)*npar2
        bic2 <- 2*logLik(y2) - par2
        if(bic1 >= bic2) { yy <- y1 }
        else { yy <- y2 }
        np <- dim(yy$theta)[1]
        ## separate by density: directly from estimated parameters
        pcoords <- yy$theta/max(yy$theta)
        pk <- list(np=np , pcoords=t(pcoords))
        if(pk$np < 2) {
          nullvectors <- c(nullvectors, m)
          next
        }
        v1perslice[m,] <- pk$pcoords[,1]
        ## optional glyph visualization
        if(showglyph) {
					if(rgl.cur() == 0) rglinit()
					else rgl.clear()
          if(pk$np > 2) {
            plotglyph(odfs[,m], odfvertices, pk, kdir=kdir)
            pp <- readline(
              "\nmore crossing-fiber glyphs  ? ('n' to exit) ") 
            if(pp == "n" ) { rgl.close(); showglyph <- FALSE; }
            else { rgl.clear( type = "shapes" ) }
          }
        }
        ## directions of max odf values to define (colored) lines
        gk <- gfas[m] 
        # pos <- c(z2d[m,],sl) # use yy-swapped mask
        pos <- c(z2d[m,],0) # use yy-swapped mask
        for(k in 1:min(pk$np, kdir)) {
          coords <- pk$pcoords
          zch <- coords[,k] * gk
          zch <- t(norm01(abs(zch)))
          if(q+1 > nn) {
            ck <- append(ck , numeric(nn))
            v <- rbind(v,  matrix(0, nrow=nn, ncol=3))
            nn <- nn+nn
          }
          ck[q] <- rgb(zch)
          ck[q+1] <- ck[q]
          pp <- pk$pcoords[,k]/2
          v[q,] <- pos
          v[q+1,]  <-  pp + pos
          q <- q+2
        }
      }
      cat("100% completed\n")
      ## print(proc.time() - ptm)
      ## save slice data
      q <- q-1;  
      v <- v[1:q,]
      ck <- ck[1:q]
      res <- list( q=q, v=v, ck=ck, nullvectors=nullvectors,
        v1perslice=v1perslice)
      fsave <- paste(savedir,"/vol",sl,".RData",sep="")
      save(res, file=fsave)
      cat("wrote", fsave,"\n")
    }
    else {
      fsave <- paste(savedir,"/vol",sl,".RData",sep="")
      load(fsave)
      cat("loaded", fsave, "\n")
      q <- res$q; v <- res$v; ck <- res$ck;
      nullvectors <- res$nullvectors;
      v1perslice <- res$v1perslice
    }
    cat("\n")
    ## remove null pk vectors
    nvl <- lix
    nnv <- length(nullvectors)
    if(nnv > 0) {
      nvl <- nvl-nnv
      v1perslice <- v1perslice[-nullvectors,]
      z2d <- z2d[-nullvectors,]
      gfas <- gfas[-nullvectors]
    }
    if(is.null(dim(z2d))) next
    v1perslicelist <- list(n=nvl, v1=v1perslice)
    v1count <- v1count+1
    v1list[[v1count]] <- v1perslicelist 
    ##---
    if(kshow != 1){
      ## one image per slice
      # rgl.init()
      if(sl == first) {
        rglstart(bg=bg)
      }
      if(kshow > 2) {
        segments3d(v, col=ck, lwd=2, alpha=1)
        rgl.viewpoint(theta=0, phi=15)
        par3d('windowRect'=c(0,0,600,600), 'zoom'=0.7, skipRedraw=FALSE)
        rgl.bringtotop()
      }
      texture <- FALSE
      switch(kshow,
      { ovr <- FALSE },
      { ovr <- TRUE; imgfa <- matrix(0, nr, nc); imgfa[z2d ] <- gfas },
      { ovr <- FALSE },
      { ovr <- TRUE; imgfa <- matrix(0, nr, nc); imgfa[z2d ] <- gfas },
      { ovr<- TRUE; texture <- TRUE; zfactor=0.1;
        imgfa <- matrix(0, nr, nc); imgfa[z2d ] <- gfas }, # linesrgb
      { ovr <- TRUE;
      imgfa <- slicedata$niislicets[,,1] * slicedata$mask;
      imgfa <- imgfa/max(imgfa) } )
      if(ovr) {
        bg3d(col=bg) 
        light3d()  
        gfasurf3d(imgfa, zfactor=zfactor, alpha=0.6, texture=texture,
          texturefile=texturefile)
        # rgl.viewpoint(theta=0, phi=0)
        rgl.viewpoint(theta=0, phi=15)
         par3d('windowRect'=c(0,0,600,600), 'zoom'=0.6, skipRedraw=FALSE)
          rgl.bringtotop()
      }
      if(snapshot) {
        ## sp <- tempfile(pattern="maplines", tmpdir=savedir, fileext=".png")
        sp <- paste(savedir,"/",pngfig,".png", sep="")
        readline("Prepare zoom for taking rgl.snapshot and press return ... ")
        rgl.snapshot(sp)
        cat("snapshot file", sp,"\n")
      }
    }
    ##---
    if(sl != last){
      pp <- readline("continue to next 'rg' slice ? ('n' to exit) ") 
      if(pp == "n" ) { break; }
      else { rgl.clear( type = "shapes" ) }
    }
  }
  cat("\n")
  ## save V1 directions
  if(run) {
    v1file <- paste(savedir,"/V1list.RData",sep="")
    save(v1list, file=v1file) # list of v1 vectors 
    cat("saved V1 directions ",v1file,"\n")
  }
}

